/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

/// An iterator which produces Fibonacci numbers.
struct Fibonacci {
    curr: usize,
    next: usize,
    limit: usize,
}

impl Fibonacci {
    /// Creates a new Fibonacci number generator which produces Fibonacci numbers which are less
    /// than or equal to the maximum integer supported by the host system (`usize::MAX`).
    fn new() -> Fibonacci {
        Fibonacci {
            curr: 0,
            next: 1,
            limit: usize::MAX,
        }
    }

    /// Creates a new Fibonacci number generator which produces Fibonacci numbers which are less
    /// than or equal to the given `limit`.
    fn up_to(limit: usize) -> Fibonacci {
        Fibonacci {
            curr: 0,
            next: 1,
            limit,
        }
    }

    /// Creates a new Fibonacci number generator starting with the given `curr` and `next` values
    /// which produces Fibonacci numbers which are less than or equal to the maximum integer
    /// supported by the host system (`usize::MAX`).
    fn from(curr: usize, next: usize) -> Fibonacci {
        Fibonacci {
            curr,
            next,
            limit: usize::MAX,
        }
    }

    /// Creates a new Fibonacci number generator starting with the given `curr` and `next` values
    /// which produces Fibonacci numbers which are less than or equal to the given `limit`.
    fn from_up_to(curr: usize, next: usize, limit: usize) -> Fibonacci {
        Fibonacci {
            curr,
            next,
            limit,
        }
    }
}

impl Iterator for Fibonacci {
    type Item = usize;

    /// Produces and returns the next Fibonacci number, if it is less than the limit.
    fn next(&mut self) -> Option<usize> {
        if self.curr > self.limit {
            return None;
        }
        let curr = self.curr;
        let next = if usize::MAX - self.curr < self.next {
            self.limit = 0;
            0
        } else {
            self.curr + self.next
        };
        self.curr = self.next;
        self.next = next;
        Some(curr)
    }
}

/// Returns the sum of the even Fibonacci numbers which are less than or equal to the given
/// `limit`.
fn sum_of_even_fibs_up_to(limit: usize) -> usize {
    Fibonacci::up_to(limit).filter(|x| x % 2 == 0).sum()
}

fn main() {
    let limit = 4_000_000;
    println!("{}", sum_of_even_fibs_up_to(limit));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solution() {
        let limit = 4_000_000;
        assert_eq!(sum_of_even_fibs_up_to(limit), 4613732);
    }

    #[test]
    fn test_fibonacci() {
        let mut fib = Fibonacci::new();
        let mut prev: usize = fib.next().unwrap();
        assert_eq!(prev, 0);
        let mut curr: usize = fib.next().unwrap();
        assert_eq!(curr, 1);
        for next in fib {
            assert_eq!(next - curr, prev, "prev: {}, curr: {}, next: {}, usize::MAX: {}", prev, curr, next, usize::MAX);
            (prev, curr) = (curr, next);
        }
    }

    #[test]
    fn test_fib_limit() {
        let limit = 4_000_000;
        let last = Fibonacci::up_to(limit).last().unwrap();
        let mut fib = Fibonacci::new();
        let mut last_direct = 0;
        while let Some(num) = fib.next() {
            if num > limit {
                break;
            }
            last_direct = num;
        }
        assert_eq!(last, last_direct);
    }
}
